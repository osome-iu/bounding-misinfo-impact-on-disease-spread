"""
Purpose:
    - Create a contact network by taking a stratified sample of the Twitter network.
        See 'Inputs' details below for factors considered in the stratification.

Note:
    - The contact network files generated by this script range between 13MBs and nearly 30GBs.
        As a result, we run this script with Indiana University's HPC system via SLURM.
        - For more information on SLURM, see this page: https://slurm.schedmd.com/
    - The location of the config file for this script is hard coded in the script
        with the variable 'CONFIG_FILE_PATH'.

Inputs:
    - County Voting data
        - This data will have the proportion of Republicans and Democrats
            that voted in the given region
    - Account Table (Propagated)
        - Each row represents a user
        - Columns represent user info (e.g., est. political ideology, location)
    - Mobility Matrix (SafeGraph)
        - Rows & columns represent each region and the cells represent the
            level of interaction between each region
        - Safe Graph mobility data is based on cell phone tracking data

Output:
    - Contact Network
        - Nodes are users from the Twitter network, mapped to locations
            their accounts are geolocated into.
        - Counties are only included if they have at least `min_user_thresh` unique nodes
        - Because we need location, ideology, and misinformation sharing label,
            we only sample nodes for which we have all of this information.
        - Edges are drawn probabilistically based on the Safe Graph interaction statistics.
        - File name captures when it was created and the parameters/variables
            used to create it:
        - Ex: '%Y-%m-%d_%H-%M-%s__contact_network__minusers_X__numedges_X__propsampled_X.gml' 

Authors:
    - Matthew DeVerna
    - Francesco Pierri

Acknowledgements:
    - Thank you Allessandro Flammini for helping us to optimize this code.
"""
import argparse
import configparser
import datetime
import os
import math
import random
import sys
import timeit

import igraph as ig
import numpy as np
import pandas as pd
import traceback

from collections import Counter, defaultdict
from copy import deepcopy


# UPDATE FOR YOUR OWN SYSTEM
CONFIG_FILE_PATH = (
    "/N/slate/mdeverna/bounding-misinfo-impact-on-disease-spread/abm/code/config.ini"
)


# Functions for setting up the script ------------------------------------
def load_variables_from_command_line():
    """
    Parse the needed variables from command line input.
    """
    parser = argparse.ArgumentParser(
        description="Build contact network based on passed command line arguments."
    )
    parser.add_argument(
        "--min_user_thresh", type=int, required=True, help="Minimum user threshold"
    )
    parser.add_argument(
        "--num_edges", type=int, required=True, help="Avg. number of edges to draw"
    )
    parser.add_argument(
        "--county_sample_prop",
        type=float,
        required=True,
        help="County sampling proportion",
    )

    args = parser.parse_args()

    try:
        min_user_threshold = args.min_user_thresh
        num_edges_to_draw = args.num_edges
        sample_prop = args.county_sample_prop
    except Exception as e:
        print(e)
        raise Exception("Problem loading command line arguments!")

    return min_user_threshold, num_edges_to_draw, sample_prop


def load_data_paths(config):
    """
    Parse the needed file paths from the config.ini file
    provided as command line input.

    Parameters:
    ----------
    - config (configparser.ConfigParser) : a configuration file
        that contains all variables/paths/files for this project.
    """
    try:
        county_political_path = os.path.join(
            config["PATHS"]["INTERMEDIATE_FILES"],
            config["FILES"]["COUNTY_POLITICAL_DATA"],
        )
        account_table_path = os.path.join(
            config["PATHS"]["INTERMEDIATE_FILES"],
            config["FILES"]["ACCOUNT_TABLE_PROPAGATED"],
        )
        mobility_matrix_path = os.path.join(
            config["PATHS"]["INTERMEDIATE_FILES"], config["FILES"]["MOBILITY_MATRIX"]
        )

    except Exception as e:
        print(e)
        raise Exception("Problem loading data paths!")

    return (
        county_political_path,
        account_table_path,
        mobility_matrix_path,
    )


# Functions for loading data files --------------------------------------------
def load_county_political_data(file_path):
    """
    Load the county political data as a couple of useful
    dictionaries for later in the script (see "Returns").

    Note: some county_name/string cleaning is handled in this function to
    match cleanly with the `account_table` county information later.

    Parameters:
    ----------
    - file_path (str) : the path to where the county level political data is
        saved

    Returns:
    ----------
    - location_to_fips (dict) : a dictionary mapping location strings to their
        respective county FIP code. Keys are the "cleaned-up" concatenation of
        the `state_name` and `county_name` columns in `county_political_df`
    - fip_to_vote_split (dict) : a dictionary mapping fips ids to the rep/dem
        vote split in that county
    """
    try:
        # Dataframe containing US counties, their FIP values, and proportion of
        # republican/democrat voting splits
        county_political_df = pd.read_csv(
            file_path,
            usecols=["state_name", "county_fips", "county_name", "per_gop", "per_dem"],
            dtype={
                "state_name": str,
                "county_fips": str,
                "county_name": str,
                "per_gop": float,
                "per_dem": float,
            },
        )
        # Just incase, we pad each string with a zero, should it be missing
        county_political_df["county_fips"] = [
            val.zfill(5) for val in county_political_df["county_fips"]
        ]

        # Some manual county name fixes to ensure the `concat_loc` column
        # created below matches the one that will be created within the `account_table`
        county_political_df.loc[:, "county_name"] = county_political_df.loc[
            :, "county_name"
        ].str.replace(".", "", regex=False)
        county_political_df.loc[:, "county_name"] = county_political_df.loc[
            :, "county_name"
        ].str.replace("Do√±a", "Dona", regex=False)
        county_political_df.loc[:, "county_name"] = county_political_df.loc[
            :, "county_name"
        ].str.replace("LaSalle", "La Salle", regex=False)
        county_political_df.loc[:, "county_name"] = county_political_df.loc[
            :, "county_name"
        ].str.replace("LaPorte", "La Porte", regex=False)

        # Create single column for unique string name identification
        county_political_df.loc[:, "county_name"] = county_political_df.loc[
            :, "county_name"
        ].str.title()
        county_political_df.loc[:, "state_name"] = county_political_df.loc[
            :, "state_name"
        ].str.title()
        county_political_df["concat_loc"] = (
            county_political_df["state_name"] + "-" + county_political_df["county_name"]
        ).str.replace(" ", "-")

        # ---- ---- ---- ---- ----
        # Create `location_to_fips`
        # ---- ---- ---- ---- ----
        location_to_fips = dict()
        zipper = zip(
            county_political_df["concat_loc"], county_political_df["county_fips"]
        )
        for loc, fips in zipper:
            location_to_fips.update({loc: fips})

        # ---- ---- ---- ---- ----
        # Create `fip_to_vote_split`
        # ---- ---- ---- ---- ----
        fip_to_vote_split = dict()
        zipper = zip(
            county_political_df["county_fips"],
            county_political_df["per_gop"],
            county_political_df["per_dem"],
        )

        for fip, prop_gop, prop_dem in zipper:
            fip_to_vote_split.update(
                {fip: {"prop_gop": prop_gop, "prop_dem": prop_dem}}
            )

    except Exception as e:
        print(e)
        raise Exception("Problem loading county political data!")

    return location_to_fips, fip_to_vote_split


def load_account_table(file_path, location_to_fips, min_user_thresh):
    """
    Load the account table information.

    Accounts that do not meet the minimum threshold of users to be included in
    the contact network are dropped. That is, if our data contains < `min_user_thresh`
    users geolocated in county Y, we drop all users geolocated in county Y.

    Parameters:
    ----------
    - file_path (str) : the path to where the acount table data is saved
    - location_to_fips (dict) : a dictionary mapping location strings to their
        respective county FIP code. Keys are the "cleaned-up" concatenation of
        the `state_name` and `county_name` columns in `county_political_df`
    - min_user_thresh (int) : the minimum number of users in a county to be
        included in this analysis. (greater than or equal to)

    Returns:
    ----------
    - account_table (pd.DataFrame) : account table data of users with the
        following colums:
            - "account_id"
            - "state"
            - "county"
            - "political_score"
            - "concat_loc"
            - "fip_code"
    """
    try:
        account_table = pd.read_csv(
            file_path,
            usecols=["account_id", "state", "county", "political_score"],
            dtype={
                "account_id": str,
                "state": str,
                "county": str,
                "political_score": float,
            },
        )

        # Drop users without political scores
        account_table = account_table[~account_table["political_score"].isna()]

        # Some county names have "." in them and others don't.
        #   E.g. : St. Tammanay Parish vs. St Tammany Parish
        # We fix it with the below
        account_table.loc[:, "county"] = account_table.loc[:, "county"].str.replace(
            ".", "", regex=False
        )

        # Create single column for unique string name identification
        account_table.loc[:, "county"] = account_table.loc[:, "county"].str.title()
        account_table.loc[:, "state"] = account_table.loc[:, "state"].str.title()
        account_table["concat_loc"] = (
            account_table["state"] + "-" + account_table["county"]
        ).str.replace(" ", "-")

        account_table["fip_code"] = account_table["concat_loc"].map(location_to_fips)

        #  ------ ------ ------ ------
        # Remove users that fall within a county that has less users
        # than the min_user_thresh value
        # ------ ------ ------ ------

        # Returns dictionary like: {fip_id : # users in that fip}
        users_per_fip = dict(Counter(account_table["fip_code"]))

        # Adds new column which shows, for each user i, the total number of users in
        # the county user i is geolocated within
        account_table["num_users_in_county"] = account_table["fip_code"].map(
            users_per_fip
        )

        # Drop users in counties with less users than the threshold
        account_table = account_table[
            account_table["num_users_in_county"] >= min_user_thresh
        ].reset_index(drop=True)

    except Exception as e:
        print(e)
        raise Exception("Problem loading account table data!")

    return account_table


def load_mobility_data(file_path):
    """
    Load the SafeGraph mobility matrix.

    Parameters:
    ----------
    - file_path (str) : the path to where the mobility matrix is saved
    - num_edges (int) : the number of edges that we want to approximately
        draw for each node

    Returns:
    ----------
    - mobility_matrix (numpy.ndarray) - the mobility matrix
    - county_size (numpy.ndarray) - an array with rows
        that are indexed based on the `county_idx` list indices and each item
        represents the population of that county
    - fips_idx (list) - a list where each item is a FIPS county integer and
        the index for that county is representative of where that county is
        located in the `country_matrix` as well as the `county_size` array
    """
    try:
        # Load central data dictionary
        data = np.load(file_path, allow_pickle=True).item()

        # Retrieve each piece
        mobility_matrix = data["county_matrix"]
        county_sizes = data["county_size"]
        fips_idx = data["county_idx"]

        # FIPs values are integers. This converts them to strings and adds
        # a leading zero, if needed (all FIPs values need to be 5 digits).
        fips_idx = [str(fip).zfill(5) for fip in fips_idx]

    except Exception as e:
        print(e)
        raise Exception("Problem loading mobility data!")

    return mobility_matrix, county_sizes, fips_idx


# Functions for creating the contact network ----------------------------------
def populate_graph(nodeID_to_data):
    """
    Add sampled users as nodes to an undirected graph.

    Parameters:
    ----------
    - nodeID_to_data (dict) : node IDs (matching rep/dem vote split)
        which map to their fip, political score, and user ID

    Returns:
    ----------
    - contact_net (networkx.Graph) : contact network with the users from
        `nodeID_to_data` added to the network. No edges have been drawn yet.
    """
    try:
        # Add nodes and attributes
        contact_net = ig.Graph()

        # Use the nodeIDs as vertices
        contact_net.add_vertices(
            str(node_id) for node_id in list(nodeID_to_data.keys())
        )
        # Assign them empty attribute values
        contact_net.vs["fip"] = [None for _ in range(contact_net.vcount())]
        contact_net.vs["politicalScore"] = [None for _ in range(contact_net.vcount())]
        contact_net.vs["userID"] = [None for _ in range(contact_net.vcount())]

        # Add attribute values
        for nodeID, data in nodeID_to_data.items():
            contact_net.vs.find(str(nodeID))["fip"] = data["fip"]
            contact_net.vs.find(str(nodeID))["politicalScore"] = data["political_score"]
            contact_net.vs.find(str(nodeID))["userID"] = data["userID"]
    except Exception as e:
        print("NodeID", nodeID)
        print("Data", data)
        traceback.print_exc()
        print(e)
        raise Exception("Problem populating the contact network!")

    return contact_net


def draw_edges(contact_net, fip_idx_to_node_ids, present_fip_idx, mobility_matrix):
    """
    Draw the edges of the populated contact network.

    The number of edges to draw is based on the cells
    of the transformed mobility matrix.

    Parameters:
    ----------
    - contact_net (networkx.Graph) : contact network with the users from
        `nodeID_to_data` added to the network. No edges have been drawn yet.
    - fip_idx_to_node_ids (defaultdict(list)) : maps fips to list of sampled node IDs
        geolocated within that fip
    - present_fips_idx (list) : contains the indices of all fips
        present in this sample. The indices correspond to their position within the
        mobility matrix.
    - mobility_matrix (list of lists) : the SafeGraph mobility matrix
    """
    try:
        # Copy the set of present fip indices and shuffle them
        counties1 = deepcopy(list(present_fip_idx))
        counties2 = deepcopy(list(present_fip_idx))
        random.shuffle(counties1)
        random.shuffle(counties2)

        print(f"Drawing edges for {len(present_fip_idx):,} counties...")
        completed_counties = 0

        edges = set()

        for county_idx1 in counties1:
            completed_counties += 1
            for county_idx2 in counties2:
                # Ensure we only draw from the upper triangle
                if not county_idx1 <= county_idx2:
                    continue

                num_edges_to_draw = mobility_matrix[county_idx1, county_idx2]
                num_edges_to_draw = int(num_edges_to_draw)

                for _ in range(num_edges_to_draw):
                    node1 = random.choice(fip_idx_to_node_ids[county_idx1])

                    # The block below is designed to avoid drawing self-loops
                    # We randomly draw a node until it is not the same as the
                    # first node. The `count` is a super unnecessary safeguard.

                    count = 0
                    node2 = node1
                    while node2 == node1:
                        count += 1
                        node2 = random.choice(fip_idx_to_node_ids[county_idx2])

                        # This is impossible for different counties and the probability
                        # of this happening for drawing edges within the same county is
                        # astronomically low, since the minimum number of users per county is 200.
                        if count > 5_000:
                            print(f"Breaking for {county_idx1} and {county_idx2}")
                            break

                    edges.add((str(node1), str(node2)))

            # Update about progress
            percent_complete = (completed_counties / len(present_fip_idx)) * 100
            print(
                f"Counties complete: {completed_counties} || "
                f"{np.round(percent_complete, 2)}%"
            )

        print("All edges have been compiled, attempting to add them to the graph now.")

        contact_net.add_edges(edges)
        print("Success.")

    except Exception:
        print(f"Number of edges: {len(edges)}")
        traceback.print_exc()
        print("Experienced an issue drawing edges between counties...")
        print(f"\tBelow are the mobility matrix indices for these counties:")
        print(f"\t - {county_idx1}")
        print(f"\t - {county_idx2}")

    return contact_net


# Other useful functions ------------------------------------------------------
def create_fips_to_idx_map(fips_idx):
    """
    Create dictionary mapping fips number to mobility matrix row/col index

    Parameters:
    ----------
    - fips_idx (list) : contains FIPs numbers where index of FIP_i = FIP_i
        row/col index within `mobility_matrix` and `county_sizes`

    Returns:
    ----------
    - fips_to_idx (dict) : maps county FIP to mobility matrix row/col index value
    """
    try:
        fips_to_idx = {val: fips_idx.index(val) for val in fips_idx}

    except Exception as e:
        print(e)
        raise Exception("Problem creating `fips_to_idx` dictionary!")

    return fips_to_idx


def get_users_from_account_table(
    account_table,
    fip_to_vote_split,
    fips_to_idx,
    county_sizes,
    sample_prop,
    fips_list=None,
):
    """
    Return a list of users from the user account table that have been
    geolocated within the counties in `fips_list`.

    Parameters:
    ----------
    - account_table (pandas.DataFrame) : a data frame containing user
        information (this is the output from `load_account_table()` )
    - fip_to_vote_split (dict) : dictionary mapping fip to the vote split
        between democrats and republicans
    - fips_to_idx (dict) : maps county FIP to mobility matrix index
    - county_sizes (np.array): an array with the population of each county. Population at
        index i maps to the county/fip index in `fips_to_idx`
    - sample_prop (float) : size of the sample to take from each county.
        Must be a value `x` such that 0 <= `x` <= 1.
    - fips_list (None or list) : If `None`, all fips in `account_table` (already
        filtered by the MIN_USER_THRESH paramter) are taken. If a list is
        passed, we consider only these fips (still from the filtered `account_table`
        dataframe)

    Returns:
    ----------
    - nodeID_to_data (dict) : a dictionary that includes the sampled nodeIDs
        as it's keys and a nested dictionary of fip ids, political
        score, and userID. The form looks like the below:
            {
                'nodeID1' : {'fip': '06037', 'political_score': -0.1066307692307692, 'userID':'3423423'},
                'nodeID2' : {...}
            }
    - fip_idx_to_node_ids (defaultdict(list)) : maps fips index in mobility matrix to list
        of sampled node IDs geolocated within that fip
    - present_fips_idx (list) : a set containing the indices of all fips present in this sample
    """
    global difference
    difference = 0

    # Throw errors if parameter types are incorrect
    if not (0 <= sample_prop <= 1):
        raise ValueError(
            "`sample_prop` must be a value between 0 and 1. "
            f"Currently, it is: {sample_prop}"
        )
    if fips_list is None:
        fips_list = account_table["fip_code"].unique()

    try:
        nodeID_to_data = dict()
        fip_idx_to_node_ids = defaultdict(list)

        for fip in fips_list:
            single_fip_df = account_table[account_table["fip_code"] == fip]

            # Get sample size
            fip_idx = fips_to_idx.get(fip)

            # This handles a couple of fips missing from SafeGraph
            if fip_idx is None:
                print(
                    f"\tSkipping FIP <{fip}> because it "
                    "is missing from SafeGraph data."
                )
                continue

            print("\n\n", "-" * 50)

            fip_pop_size = county_sizes[fip_idx]
            sample_size = fip_pop_size * sample_prop

            print(f"Population size: {fip_pop_size}")
            print(f"Sample size: {sample_size}")

            # Determine the number of rep/dem users to include based on voting split
            num_reps = math.ceil(sample_size * fip_to_vote_split[fip]["prop_gop"])
            num_dems = math.floor(sample_size * fip_to_vote_split[fip]["prop_dem"])

            print(f"# Dems to sample: {num_dems}")
            print(f"# Reps to sample: {num_reps}")
            print(f"Total to sample: {num_dems + num_reps}")

            rep_users = single_fip_df[single_fip_df["political_score"] > 0].sample(
                num_reps, replace=True
            )
            dem_users = single_fip_df[single_fip_df["political_score"] < 0].sample(
                num_dems, replace=True
            )

            print(f"# Dems sampled: {len(dem_users)}")
            print(f"# Reps sampled: {len(rep_users)}")
            print(f"Total sampled: {len(dem_users) + len(rep_users)}")

            # There is some small difference because of rounding
            difference += sample_size - (len(dem_users) + len(rep_users))
            print(f"Total Difference: {difference}")
            print("-" * 50)

            # Each node is given a unique idx "node_id"
            # First node ID is set if no nodes have been added yet
            if len(nodeID_to_data.keys()) < 1:
                node_id = 1
            else:
                # This handles the case when we move to the next fip
                node_id = max(nodeID_to_data.keys()) + 1

            # Add democrat users
            dem_zip = zip(
                dem_users["account_id"],
                dem_users["fip_code"],
                dem_users["political_score"],
            )
            for user, fip, p_score in dem_zip:
                nodeID_to_data.update(
                    {node_id: {"fip": fip, "political_score": p_score, "userID": user}}
                )
                node_id += 1

            # Add republican users
            rep_zip = zip(
                rep_users["account_id"],
                rep_users["fip_code"],
                rep_users["political_score"],
            )
            for user, fip, p_score in rep_zip:
                nodeID_to_data.update(
                    {node_id: {"fip": fip, "political_score": p_score, "userID": user}}
                )
                node_id += 1

            # -- Use nodeID_to_data to create fip_idx_to_node_ids --
            #  Form: {fip_idx1: [nodeID1, nodeID2, ...], fip_idx2: [list of node IDs present in this fip], ...}
            # NOTE: fip_idx here is the index of that fip within the mobility matrix, used later
            # for drawing edges.
            for nodeID, data in nodeID_to_data.items():
                fip_idx_to_node_ids[fips_to_idx[data["fip"]]].append(nodeID)

            # -- Create `present_fips_idx` --
            # Get all fips in account table
            acnt_fips = list(set(account_table["fip_code"]))
            acnt_fips.remove(np.nan)

            present_fip_idx = set()
            for fip in acnt_fips:
                present_fip_idx.add(fips_to_idx.get(fip))

            # Remove None value from the set.
            # These represent users we have geolocated
            # in places like Alaska, Puerto Rico, etc.
            present_fip_idx.remove(None)

        print(f"Number of keys (users) in dictionary: {len(nodeID_to_data.keys()):,}")

    except Exception as e:
        print(e)
        raise Exception("Problem getting users from account table!")

    return nodeID_to_data, fip_idx_to_node_ids, present_fip_idx


def transform_matrix(mobility_matrix, present_fip_idx, num_nodes, num_edges):
    """
    Transform the mobility matrix so that each cell contains
    the number of edges that should be drawn between each county pair.

    Parameters:
    ----------
    - mobility_matrix (numpy.ndarray) : the mobility matrix
    - present_fip_idx (set) : the indices of all present fip
        codes in our sampled data
    - num_nodes (int) : the number of nodes that are in our
        populated contact network
    - num_edges (int) : the number of edges we would like to
        approximately draw for each node
    """
    try:
        total_edges_to_draw = num_nodes * (num_edges / 2)

        # Remove counties which never appear
        for i in range(mobility_matrix.shape[0]):
            if i not in present_fip_idx:
                mobility_matrix[i, :] = np.zeros(mobility_matrix.shape[0])
                mobility_matrix[:, i] = np.zeros(mobility_matrix.shape[0])

        # Normalize the upper triangle by it's sum
        #   We take only the upper triangle because we do
        #   not consider the bottom triangle when we later draw edges
        mobility_matrix = np.triu(mobility_matrix) / np.triu(mobility_matrix).sum()

        # Now scale this matrix by the number of edges we'd like to draw
        mobility_matrix = mobility_matrix * total_edges_to_draw

    except Exception as e:
        print(e)
        raise Exception("Problem transforming the mobility matrix!")

    return mobility_matrix


def create_output_file_name(min_user_threshold, num_edges_to_draw, sample_prop):
    """
    Function to create an output file name that captures the important
    information about how the network was created.
    """
    try:
        now = datetime.datetime.strftime(datetime.datetime.now(), "%Y-%m-%d_%H-%M-%S")
        output_name = (
            f"{now}__contact_network__"
            f"minusers_{min_user_threshold}__"
            f"numedges_{num_edges_to_draw}__"
            f"propsampled_{sample_prop}.gml"
        )
    except Exception as e:
        print(e)
        raise Exception("Problem creating output file name!")
    return output_name


def check_file_exists(min_user_threshold, num_edges_to_draw, sample_prop, output_dir):
    """
    Check if a file with the specified parameters already exists in the output directory.
    Ignores the datetime part of the file name.
    """
    try:
        # Construct the parameter part of the file name
        param_part = (
            f"contact_network__"
            f"minusers_{min_user_threshold}__"
            f"numedges_{num_edges_to_draw}__"
            f"propsampled_{sample_prop}.gml"
        )

        for file in os.listdir(output_dir):
            if file.endswith(param_part):
                return True

        return False

    except Exception as e:
        print(e)
        raise Exception("Problem checking if file exists!")


# Main function ---------------------------------------------------------------
def main():
    start = timeit.default_timer()
    try:
        print("Parsing command line arguments...")
        (
            min_user_threshold,
            num_edges_per_node,
            sample_prop,
        ) = load_variables_from_command_line()

        print("Using args to build output file name...")
        fname = create_output_file_name(
            min_user_threshold, num_edges_per_node, sample_prop
        )

        print("Loading config file to access data paths...")
        config = configparser.ConfigParser()
        config.read(CONFIG_FILE_PATH)

        output_dir = config["PATHS"]["CNETS_DIR"]
        file_exists = check_file_exists(
            min_user_threshold, num_edges_per_node, sample_prop, output_dir
        )
        if file_exists:
            print(f"File already exists!")
            print(f"Filename: {fname}")
            print(f"Location: {output_dir}")
            sys.exit(0)

        print("Loading data paths...")
        (
            county_political_path,
            account_table_path,
            mobility_matrix_path,
        ) = load_data_paths(config)

        print("Parameters being utilized for contact network construction:")
        print("---------------------------------------")
        print(f"\t- Min. users per county    : {min_user_threshold}")
        print(f"\t- Expected edges per node  : {num_edges_per_node}")
        print(f"\t- Sample size proportion   : {sample_prop}")
        print("---------------------------------------")
        print(f"Output filename: {fname}")

        print("Loading county data...")
        location_to_fips, fip_to_vote_split = load_county_political_data(
            county_political_path
        )

        print("Loading propagated account table...")
        account_table = load_account_table(
            account_table_path, location_to_fips, min_user_thresh=min_user_threshold
        )

        print("Loading mobility data...")
        mobility_matrix, county_sizes, fips_idx = load_mobility_data(
            mobility_matrix_path
        )
        fips_to_idx = create_fips_to_idx_map(fips_idx)

        print("Sampling users from the account table...")
        (
            nodeID_to_data,
            fip_idx_to_node_ids,
            present_fips_idx,
        ) = get_users_from_account_table(
            account_table, fip_to_vote_split, fips_to_idx, county_sizes, sample_prop
        )

        print("Populating a graph with the sampled users...")
        contact_net = populate_graph(nodeID_to_data)

        print("Transforming the mobility matrix...")
        num_nodes = contact_net.vcount()
        mobility_matrix = transform_matrix(
            mobility_matrix, present_fips_idx, num_nodes, num_edges_per_node
        )

        print(
            f"Begin drawing edges (n = {num_edges_per_node}) for {num_nodes} nodes..."
        )
        draw_edges(contact_net, fip_idx_to_node_ids, present_fips_idx, mobility_matrix)

        print(
            "Contact network has been drawn with:\n"
            f"\t - Num edges: {contact_net.ecount():,.0f}\n"
            f"\t - Num nodes: {contact_net.vcount():,.0f}\n"
        )
        print("Writing network to disk...")
        os.makedirs(output_dir, exist_ok=True)
        outfname = os.path.join(output_dir, fname)
        contact_net.save(outfname, format="gml")

        time_to_run = timeit.default_timer() - start
        print(f"Script took {time_to_run/60} minutes to run.")
        print("Script complete.")

    except Exception as e:
        print("The script has run into an error!\n")
        print(e)
        print(
            "\nTo preserve what has been created already, I will save the "
            " unfinished network as it is."
        )
        fname = fname.replace(".gml", "__INCOMPLETE.gml")
        os.makedirs(output_dir, exist_ok=True)
        outfname = os.path.join(output_dir, fname)
        contact_net.save(outfname, format="gml")


if __name__ == "__main__":
    try:
        main()

    except Exception as e:
        print(e)
        print("Something went wrong with the current script: " f"{__file__}")
